第一次运行honeyvault代码

首先使用的小数据集，2016、2021、transformer三个模型能够一次性跑通

后来切换到700w数据集，跑了大约三四天，在precomputing weights of  PwSimilarityAttackOverlap这里停下，cpu利用率极低（不超过10%）

![Image](https://github.com/user-attachments/assets/d7f53ed7-7cd0-4c20-a64e-a20275d2fc2b)

加入一个空的.h5权重，代码继续运行，过一段时间后在precomputing weights of PwSimilarityAttackOverlap这里停下

过了一晚上，程序依旧停在这里

后来按Ctrl+C强制退出并重新跑（多次进行这个操作），此时只跑transformer模型，跑出了结果

第二次运行honeyvault代码（重新下载代码）

因为在第一次跑代码时，使用的小数据集，能够跑通，所以这次运行代码首先使用的700w的数据集

在跑了四天后，在precomputing weights of PwSimilarityAttackOverlap这里停下

<img width="1878" height="599" alt="Image" src="https://github.com/user-attachments/assets/cf81981f-39b7-41f3-9e0b-93c38c7fdb3e" />

cpu利用率极低

<img width="2533" height="1121" alt="Image" src="https://github.com/user-attachments/assets/200d7eaf-5d55-4cf1-bf50-1480bc58a2a7" />

<img width="2546" height="1278" alt="Image" src="https://github.com/user-attachments/assets/e2b7fb82-55ef-4aa2-9947-88342b76a1b7" />

在这里停了一晚上的时间后，按Ctrl+C强制退出并只跑transformer模型，依旧在precomputing weights of PwSimilarityAttackOverlap这里停下

<img width="1548" height="302" alt="Image" src="https://github.com/user-attachments/assets/f54447b8-d7f2-4a26-be87-fe6c29f82207" />

cpu利用率极低

<img width="2394" height="603" alt="Image" src="https://github.com/user-attachments/assets/af35aba0-cc2b-44ba-8fb1-5562533b8f58" />



我在src\honeyvault\__main__.py添加了能够打印堆栈轨迹和错误的代码

    import logging
    import sys
    import faulthandler
    
    from pathlib import Path
    
    def _setup_file_logging():
    
        log_dir = Path(r"log")
    
        log_dir.mkdir(parents=True, exist_ok=True)
    
        log_path = log_dir / "run.log"
    
        logging.basicConfig(
    
            level=logging.INFO,
    
            format="%(asctime)s | %(levelname)s | %(pathname)s:%(lineno)d | %(funcName)s | %(message)s",
    
            handlers=[logging.FileHandler(log_path, encoding="utf-8")],
    
        )
    
        # faulthandler 需要一个文件对象
    
        log_file = open(log_path, "a", buffering=1, encoding="utf-8")
    
        # 捕获未处理异常写入日志
    
        def _log_uncaught_exceptions(exc_type, exc, tb):
    
            logging.critical("Unhandled exception", exc_info=(exc_type, exc, tb))
    
        sys.excepthook = _log_uncaught_exceptions
    
        # 开启卡停堆栈 dump（会把所有线程堆栈写到同一个日志）
    
        faulthandler.enable(file=log_file, all_threads=True)
    
        # 600 秒没有结束就 dump 一次
    
        faulthandler.dump_traceback_later(600, repeat=True, file=log_file)
    
    _setup_file_logging()
